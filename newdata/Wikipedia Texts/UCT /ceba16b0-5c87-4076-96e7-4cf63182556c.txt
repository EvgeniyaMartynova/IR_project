Monte Carlo tree search

In computer science, Monte Carlo tree search (MCTS) is a heuristic search algorithm for some kinds of decision processes, most notably those employed in game play. MCTS was introduced in 2006 for computer Go. It has been used in other board games like chess and shogi, games with incomplete information such as bridge and poker, as well as in turn-based-strategy video games (such as Total War: Rome II's implementation in the high level campaign AI).


== History ==


=== Monte Carlo Method ===
The Monte Carlo method, which uses randomness for deterministic problems difficult or impossible to solve using other approaches, dates back to the 1940s. In his 1987 PhD thesis, Bruce Abramson combined minimax search with an expected-outcome model based on random game playouts to the end, instead of the usual static evaluation function. Abramson said the expected-outcome model "is shown to be precise, accurate, easily estimable, efficiently calculable, and domain-independent."  He experimented in-depth with Tic-tac-toe and then with machine-generated evaluation functions for Othello and Chess.
Such methods were then explored and successfully applied to heuristic search in the field of automated theorem proving by W. Ertel, J. Schumann and C. Suttner in 1989, thus improving the exponential search times of uninformed search algorithms such as e.g. breadth-first search, depth-first search or iterative deepening.
In 1992, B. Brügmann employed it for the first time in a Go-playing program. Chang et al. proposed the idea of "recursive rolling out and backtracking" with "adaptive" sampling choices in their Adaptive Multi-stage Sampling (AMS) algorithm for the model of Markov decision processes. AMS was the first work to explore the idea of UCB-based exploration and exploitation in constructing sampled/simulated (Monte Carlo) trees and was the main seed for UCT (Upper Confidence Trees).


=== Monte Carlo Tree Search (MCTS) ===

In 2006, inspired by these predecessors, Rémi Coulom described the application of the Monte Carlo method to game-tree search and coined the name Monte Carlo tree search, L. Kocsis and Cs. Szepesvári developed the UCT (Upper Confidence bounds applied to Trees) algorithm, and S. Gelly et al. implemented UCT in their program MoGo. In 2008, MoGo achieved dan (master) level in 9×9 Go, and the Fuego program began to win against strong amateur players in 9×9 Go.In January 2012, the Zen program won 3:1 in a Go match on a 19×19 board with an amateur 2 dan player. Google Deepmind developed the program AlphaGo, which in October 2015 became the first Computer Go program to beat a professional human Go player without handicaps on a full-sized 19x19 board. In March 2016, AlphaGo was awarded an honorary 9-dan (master) level in 19×19 Go for defeating Lee Sedol in a five-game match with a final score of four games to one. AlphaGo represents a significant improvement over previous Go programs as well as a milestone in machine learning as it uses Monte Carlo tree search with artificial neural networks (a deep learning method) for policy (move selection) and value, giving it efficiency far surpassing previous programs.MCTS algorithm has also been used in programs that play other board games (for example Hex, Havannah, Game of the Amazons, and Arimaa), real-time video games (for instance Ms. Pac-Man and Fable Legends), and nondeterministic games (such as skat, poker, Magic: The Gathering, or Settlers of Catan).


== Principle of operation ==
The focus of MCTS is on the analysis of the most promising moves, expanding the search tree based on random sampling of the search space.
The application of Monte Carlo tree search in games is based on many playouts also called roll-outs. In each playout, the game is played out to the very end by selecting moves at random. The final game result of each playout is then used to weight the nodes in the game tree so that better nodes are more likely to be chosen in future playouts.
The most basic way to use playouts is to apply the same number of playouts after each legal move of the current player, then choose the move which led to the most victories. The efficiency of this method—called Pure Monte Carlo Game Search—often increases with time as more playouts are assigned to the moves that have frequently resulted in the current player's victory according to previous playouts. Each round of Monte Carlo tree search consists of four steps:
Selection: start from root R and select successive child nodes until a leaf node L is reached. The root is the current game state and a leaf is any node from which no simulation (playout) has yet been initiated. The section below says more about a way of biasing choice of child nodes that lets the game tree expand towards the most promising moves, which is the essence of Monte Carlo tree search.
Expansion: unless L ends the game decisively (e.g. win/loss/draw) for either player, create one (or more) child nodes and choose node C from one of them. Child nodes are any valid moves from the game position defined by L.
Simulation: complete one random playout from node C. This step is sometimes also called playout or rollout. A playout may be as simple as choosing uniform random moves until the game is decided (for example in chess, the game is won, lost, or drawn).
Backpropagation: use the result of the playout to update information in the nodes on the path from C to R.
This graph shows the steps involved in one decision, with each node showing the ratio of wins to total playouts from that point in the game tree for the player that node represents. In the Selection diagram, black is about to move. The root node shows there are 11 wins out of 21 playouts for white from this position so far. It complements the total of 10/21 black wins shown along the three black nodes under it, each of which represents a possible black move.
If white loses the simulation, all nodes along the selection incremented their simulation count (the denominator), but among them only the black nodes were credited with wins (the numerator). If instead white wins, all nodes along the selection would still increment their simulation count, but among them only the white nodes would be credited with wins. In games where draws are possible, a draw causes the numerator for both black and white to be incremented by 0.5 and the denominator by 1. This ensures that during selection, each player's choices expand towards the most promising moves for that player, which mirrors the goal of each player to maximize the value of their move.
Rounds of search are repeated as long as the time allotted to a move remains. Then the move with the most simulations made (i.e. the highest denominator) is chosen as the final answer.


== Pure Monte Carlo game search ==
This basic procedure can be applied to any game whose positions necessarily have a finite number of moves and finite length. For each position, all feasible moves are determined: k random games are played out to the very end, and the scores are recorded. The move leading to the best score is chosen. Ties are broken by fair coin flips. Pure Monte Carlo Game Search results in strong play in several games with random elements, as in the game EinStein würfelt nicht!. It converges to optimal play (as k tends to infinity) in board filling games with random turn order, for instance in Hex with random turn order. DeepMind's AlphaZero replaces the simulation step with an evaluation based on a neural network.


== Exploration and exploitation ==
The main difficulty in selecting child nodes is maintaining some balance between the exploitation of deep variants after moves with high average win rate and the exploration of moves with few simulations. The first formula for balancing exploitation and exploration in games, called UCT (Upper Confidence Bound 1 applied to trees), was introduced by Levente Kocsis and Csaba Szepesvári. UCT is based on the UCB1 formula derived by Auer, Cesa-Bianchi, and Fischer and the provably convergent AMS (Adaptive Multi-stage Sampling) algorithm first applied to multi-stage decision making models (specifically, Markov Decision Processes) by Chang, Fu, Hu, and Marcus. Kocsis and Szepesvári recommend to choose in each node of the game tree the move for which the expression 
  
    
      
        
          
            
              w
              
                i
              
            
            
              n
              
                i
              
            
          
        
        +
        c
        
          
            
              
                ln
                ⁡
                
                  N
                  
                    i
                  
                
              
              
                n
                
                  i
                
              
            
          
        
      
    
    {\displaystyle {\frac {w_{i}}{n_{i}}}+c{\sqrt {\frac {\ln N_{i}}{n_{i}}}}}
   has the highest value. In this formula:

wi stands for the number of wins for the node considered after the i-th move
ni stands for the number of simulations for the node considered after the i-th move
Ni stands for the total number of simulations after the i-th move run by the parent node of the one considered
c is the exploration parameter—theoretically equal to √2; in practice usually chosen empiricallyThe first component of the formula above corresponds to exploitation; it is high for moves with high average win ratio. The second component corresponds to exploration; it is high for moves with few simulations.
Most contemporary implementations of Monte Carlo tree search are based on some variant of UCT that traces its roots back to the AMS simulation optimization algorithm for estimating the value function in finite-horizon Markov Decision Processes (MDPs) introduced by Chang et al. (2005) in Operations Research. (AMS was the first work to explore the idea of UCB-based exploration and exploitation in constructing sampled/simulated (Monte Carlo) trees and was the main seed for UCT.)


== Advantages and disadvantages ==
Although it has been proven that the evaluation of moves in Monte Carlo tree search converges to minimax, the basic version of Monte Carlo tree search converges only in so called "Monte Carlo Perfect" games. However Monte Carlo tree search does offer significant advantages over alpha–beta pruning and similar algorithms that minimize the search space.
In particular, pure Monte Carlo tree search does not need an explicit evaluation function. Simply implementing the game's mechanics is sufficient to explore the search space (i.e. the generating of allowed moves in a given position and the game-end conditions). As such, Monte Carlo tree search can be employed in games without a developed theory or in general game playing.
The game tree in Monte Carlo tree search grows asymmetrically as the method concentrates on the more promising subtrees. Thus it achieves better results than classical algorithms in games with a high branching factor.
Moreover, Monte Carlo tree search can be interrupted at any time yielding the most promising move already found.
A disadvantage is that, in a critical position against an expert player, there may be a single branch which leads to a loss. Because this is not easily found at random, the search may not "see" it and will not take it into account. It is believed that this may have been part of the reason for AlphaGo's loss in its fourth game against Lee Sedol. In essence, the search attempts to prune sequences which are less relevant. In some cases, a play can lead to a very specific line of play which is significant, but which is overlooked when the tree is pruned, and this outcome is therefore "off the search radar".


== Improvements ==
Various modifications of the basic Monte Carlo tree search method have been proposed to shorten the search time. Some employ domain-specific expert knowledge, others do not.
Monte Carlo tree search can use either light or heavy playouts. Light playouts consist of random moves while heavy playouts apply various heuristics to influence the choice of moves. These heuristics may employ the results of previous playouts (e.g. the Last Good Reply heuristic) or expert knowledge of a given game. For instance, in many Go-playing programs certain stone patterns in a portion of the board influence the probability of moving into that area. Paradoxically, playing suboptimally in simulations sometimes makes a Monte Carlo tree search program play stronger overall.

Domain-specific knowledge may be employed when building the game tree to help the exploitation of some variants. One such method assigns nonzero priors to the number of won and played simulations when creating each child node, leading to artificially raised or lowered average win rates that cause the node to be chosen more or less frequently, respectively, in the selection step. A related method, called progressive bias, consists in adding to the UCB1 formula a 
  
    
      
        
          
            
              b
              
                i
              
            
            
              n
              
                i
              
            
          
        
      
    
    {\displaystyle {\frac {b_{i}}{n_{i}}}}
   element, where bi is a heuristic score of the  i-th move.The basic Monte Carlo tree search collects enough information to find the most promising moves only after many rounds; until then its moves are essentially random. This exploratory phase may be reduced significantly in a certain class of games using RAVE (Rapid Action Value Estimation). In these games, permutations of a sequence of moves lead to the same position. Typically, they are board games in which a move involves placement of a piece or a stone on the board. In such games the value of each move is often only slightly influenced by other moves.
In RAVE, for a given game tree node N, its child nodes Ci store not only the statistics of wins in playouts started in node N but also the statistics of wins in all playouts started in node N and below it, if they contain move i (also when the move was played in the tree, between node N and a playout). This way the contents of tree nodes are influenced not only by moves played immediately in a given position but also by the same moves played later.

When using RAVE, the selection step selects the node, for which the modified UCB1 formula 
  
    
      
        (
        1
        −
        β
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        )
        
          
            
              w
              
                i
              
            
            
              n
              
                i
              
            
          
        
        +
        β
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        
          
            
              
                
                  
                    w
                    ~
                  
                
              
              
                i
              
            
            
              
                
                  
                    n
                    ~
                  
                
              
              
                i
              
            
          
        
        +
        c
        
          
            
              
                ln
                ⁡
                t
              
              
                n
                
                  i
                
              
            
          
        
      
    
    {\displaystyle (1-\beta (n_{i},{\tilde {n}}_{i})){\frac {w_{i}}{n_{i}}}+\beta (n_{i},{\tilde {n}}_{i}){\frac {{\tilde {w}}_{i}}{{\tilde {n}}_{i}}}+c{\sqrt {\frac {\ln t}{n_{i}}}}}
   has the highest value. In this formula, 
  
    
      
        
          
            
              
                w
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {w}}_{i}}
   and 
  
    
      
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {n}}_{i}}
   stand for the number of won playouts containing move i and the number of all playouts containing move i, and the 
  
    
      
        β
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})}
   function should be close to one and to zero for relatively small and relatively big ni and 
  
    
      
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {n}}_{i}}
  , respectively. One of many formulas for 
  
    
      
        β
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})}
  , proposed by D. Silver, says that in balanced positions one can take 
  
    
      
        β
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        =
        
          
            
              
                
                  
                    n
                    ~
                  
                
              
              
                i
              
            
            
              
                n
                
                  i
                
              
              +
              
                
                  
                    
                      n
                      ~
                    
                  
                
                
                  i
                
              
              +
              4
              
                b
                
                  2
                
              
              
                n
                
                  i
                
              
              
                
                  
                    
                      n
                      ~
                    
                  
                
                
                  i
                
              
            
          
        
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})={\frac {{\tilde {n}}_{i}}{n_{i}+{\tilde {n}}_{i}+4b^{2}n_{i}{\tilde {n}}_{i}}}}
  , where b is an empirically chosen constant.
Heuristics used in Monte Carlo tree search often require many parameters. There are automated methods to tune the parameters to maximize the win rate.Monte Carlo tree search can be concurrently executed by many threads or processes. There are several fundamentally different methods of its parallel execution:
Leaf parallelization, i.e. parallel execution of many playouts from one leaf of the game tree.
Root parallelization, i.e. building independent game trees in parallel and making the move basing on the root-level branches of all these trees.
Tree parallelization, i.e. parallel building of the same game tree, protecting data from simultaneous writes either with one, global mutex, with more mutexes, or with non-blocking synchronization.


== See also ==
AlphaGo, a Go program using Monte Carlo tree search, reinforcement learning and deep learning.
AlphaGo Zero, an updated Go program using Monte Carlo tree search, reinforcement learning and deep learning.
AlphaZero, a generalized version of AlphaGo Zero using Monte Carlo tree search, reinforcement learning and deep learning.
Leela Chess Zero, a free software implementation of AlphaZero's methods to chess, which is currently among the leading chess playing programs.


== References ==


== Bibliography ==
Cameron Browne; Edward Powley; Daniel Whitehouse; Simon Lucas; Peter I. Cowling; Philipp Rohlfshagen; Stephen Tavener; Diego Perez; Spyridon Samothrakis; Simon Colton (March 2012). "A Survey of Monte Carlo Tree Search Methods". IEEE Transactions on Computational Intelligence and AI in Games. 4 (1): 1–43. CiteSeerX 10.1.1.297.3086. doi:10.1109/tciaig.2012.2186810.