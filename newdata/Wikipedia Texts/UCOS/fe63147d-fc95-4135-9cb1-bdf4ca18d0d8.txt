MicroC/OS-II

Micro-Controller Operating Systems (MicroC/OS, stylized as μC/OS) is a real-time operating system (RTOS) designed by embedded software developer, Jean J. Labrosse in 1991. It is a priority-based preemptive real-time kernel for microprocessors, written mostly in the programming language C. It is intended for use in embedded systems.
MicroC/OS allows defining several functions in C, each of which can execute as an independent thread or task. Each task runs at a different priority, and runs as if it owns the central processing unit (CPU). Lower priority tasks can be preempted by higher priority tasks at any time. Higher priority tasks use operating system (OS) services (such as a delay or event) to allow lower priority tasks to execute. OS services are provided for managing tasks and memory, communicating between tasks, and timing.


== History ==
The MicroC/OS kernel was published originally in a three-part article in Embedded Systems Programming magazine and the book μC/OS The Real-Time Kernel by Jean J. Labrosse (ISBN 0-87930-444-8). The author intended at first to simply describe the internals of a portable operating system he had developed for his own use, but later developed the OS as a commercial product in versions II and III.


== μC/OS-II ==
Based on the source code written for μC/OS, and introduced as a commercial product in 1998, μC/OS-II is a portable, ROM-able, scalable, preemptive, real-time, deterministic, multitasking kernel for microprocessors, and digital signal processors (DSPs). It manages up to 255 application tasks. Its size can be scaled (between 5 and 24 Kbytes) to only contain the features needed for a given use.
Most of μC/OS-II is written in highly portable ANSI C, with target microprocessor-specific code written in assembly language. Use of the latter is minimized to ease porting to other processors.


=== Uses in embedded systems ===
μC/OS-II was designed for embedded uses. If the producer has the proper tool chain (i.e., C compiler, assembler, and linker-locator), μC/OS-II can be embedded as part of a product.
μC/OS-II is used in many embedded systems, including:

Avionics
Medical equipment and devices
Data communications equipment
White goods (appliances)
Mobile phones, personal digital assistants (PDAs), MIDs
Industrial controls
Consumer electronics
Automotive


=== Task states ===
μC/OS-II is a multitasking operating system. Each task is an infinite loop and can be in any one of the following five states (see figure below additionally)

Dormant
Ready
Running
Waiting (for an event)
Interrupted (interrupt service routine (ISR))Further, it can manage up to 255 tasks. However, it is recommended that eight of these tasks be reserved for μC/OS-II, leaving an application up to 247 tasks.


=== Kernels ===
The kernel is the name given to the program that does most of the housekeeping tasks for the operating system. The boot loader hands control over to the kernel, which initializes the various devices to a known state and makes the computer ready for general operations. The kernel is responsible for managing tasks (i.e., for managing the CPU's time) and communicating between tasks. The fundamental service provided by the kernel is context switching.
The scheduler is the part of the kernel responsible for determining which task runs next. Most real-time kernels are priority based. In a priority-based kernel, control of the CPU is always given to the highest priority task ready to run. Two types of priority-based kernels exist: non-preemptive and preemptive.  Nonpreemptive kernels require that each task do something to explicitly give up control of the CPU. A preemptive kernel is used when system responsiveness is more important. Thus, μC/OS-II and most commercial real-time kernels are preemptive. The highest priority task ready to run is always given control of the CPU.


=== Assigning tasks ===
Tasks with the highest rate of execution are given the highest priority using rate-monotonic scheduling. This scheduling algorithm is used in real-time operating systems (RTOS) with a static-priority scheduling class.


=== Managing tasks ===
In computing, a task is a unit of execution. In some operating systems, a task is synonymous with a process, in others with a thread. In batch processing computer systems, a task is a unit of execution within a job.
The system user of μC/OS-II is able to control the tasks by using the following features:

Task feature
Task creation
Task stack & stack checking
Task deletion
Change a task's priority
Suspend and resume a task
Get information about a task


=== Managing memory ===
To avoid fragmentation, μC/OS-II allows applications to obtain fixed-sized memory blocks from a partition made of a contiguous memory area.  All memory blocks are the same size, and the partition contains an integral number of blocks. Allocation and deallocation of these memory blocks is done in constant time and is a deterministic system.


=== Managing time ===
μC/OS-II requires that a periodic time source be provided to keep track of time delays and timeouts. A tick should occur between 10 and 1000 times per second, or Hertz. The faster the tick rate, the more overhead μC/OS-II imposes on the system. The frequency of the clock tick depends on the desired tick resolution of an application. Tick sources can be obtained by dedicating a hardware timer, or by generating an interrupt from an alternating current (AC) power line (50 or 60 Hz) signal. This periodic time source is termed a clock tick.After a clock tick is determined, tasks can be: 

Delaying a task
Resume a delayed task


=== Communicating between tasks ===
Intertask or interprocess communication in μC/OS-II occurs via: semaphores, message mailbox, message queues, tasks, and interrupt service routines (ISRs). They can interact with each other when a task or an ISR signals a task through a kernel object called an event control block (ECB). The signal is considered to be an event.


== μC/OS-III ==
μC/OS-III is the acronym for Micro-Controller Operating Systems Version 3, introduced in 2009 and adding functionality to the μC/OS-II RTOS.
μC/OS-III offers all of the features and functions of μC/OS-II. The biggest difference is the number of supported tasks. μC/OS-II allows only 1 task at each of 255 priority levels, for a maximum of 255 tasks. μC/OS-III allows any number of application tasks, priority levels, and tasks per level, limited only by processor access to memory.μC/OS-II and μC/OS-III are currently maintained by Micrium, Inc., a subsidiary of Silicon Labs, and can be licensed per product or per product line.


=== Uses in embedded systems ===
The uses are the same as for μC/OS-II


=== Task states ===
μC/OS-III is a multitasking operating system. Each task is an infinite loop and can be in any one of five states (dormant, ready, running, interrupted, or pending). Task priorities can range from 0 (highest priority) to a maximum of 255 (lowest possible priority).


=== Round robin scheduling ===
When two or more tasks have the same priority, the kernel allows one task to run for a predetermined amount of time, named a quantum, and then selects another task. This process is termed round robin scheduling or time slicing. The kernel gives control to the next task in line if:

The current task has no work to do during its time slice, or
The current task completes before the end of its time slice, or
The time slice ends.


=== Kernels ===
The kernel functionality for μC/OS-III is the same as for μC/OS-II.


=== Managing tasks ===
Task management also functions the same as for μC/OS-II, however, μC/OS-III supports multitasking and allows an application to have any number of tasks. The maximum number of tasks is limited by only the amount of memory (both code and data space) available to the processor.
A task can be implemented via run to completion scheduling, in which the task deletes itself when it is finished, or more typically as an infinite loop, waiting for events to occur and processing those events.


=== Managing memory ===
Memory management is performed in the same way as in μC/OS-II.


=== Managing time ===
μC/OS-III offers the same time managing features as μC/OS-II. It also provides services to applications so that tasks can suspend their execution for user-defined time delays. Delays are specified by a number of either clock ticks, or hours, minutes, seconds, and milliseconds.


=== Communicating between tasks ===
Sometimes, a task or ISR must communicate information to another task, because it is unsafe for two tasks to access the same specific data or hardware resource at once. This can be resolved via an information transfer, termed inter-task communication. Information can be communicated between tasks in two ways: through global data, or by sending messages.
When using global variables, each task or ISR must ensure that it has exclusive access to variables. If an ISR is involved, the only way to ensure exclusive access to common variables is to disable interrupts. If two tasks share data, each can gain exclusive access to variables by either disabling interrupts, locking the scheduler, using a semaphore, or preferably, using a mutual exclusion semaphore. Messages can be sent to either an intermediate object called a message queue, or directly to a task, since in μC/OS-III, each task has its own built-in message queue. Use an external message queue if multiple tasks are to wait for messages. Send a message directly to a task if only one task will process the data received.  While a task waits for a message to arrive, it uses no CPU time.


== Ports ==
A port involves three aspects: CPU, OS, and board specific (BSP) code. μC/OS-II and μC/OS-III have ports for most popular processors and boards in the market and are suitable for use in safety critical embedded systems such as aviation, medical systems, and nuclear installations. A μC/OS-III port involves writing or changing the contents of three kernel specific files: OS_CPU.H, OS_CPU_A.ASM, and OS_CPU_C.C. It is necessary to write or change the content of three CPU specific files: CPU.H, CPU_A.ASM, and CPU_C.C. Finally create or change a board support package (BSP) for the evaluation board or target board being used. A μC/OS-III port is similar to a μC/OS-II port. There are significantly more ports than listed here, and ports are subject to continuous development. Both μC/OS-II and μC/OS-III are supported by popular SSL/TLS libraries such as wolfSSL, which ensure security across all connections. 


== References ==


== Sources ==
Protocol Support for μC/OS-II from Fusion Embedded
Micrium-uCOS-III-UsersManual 1st Edition
uC/OS-III: The Real-Time Kernel for the Renesas RX62N


== External links ==
Official website
Summary of Commonly Used uC/OS-II Functions and Data Structures
NiosII GCC with MicroC/OS
μC/OS-II Reference Manual
How to Get a μC/OS-II Application Running